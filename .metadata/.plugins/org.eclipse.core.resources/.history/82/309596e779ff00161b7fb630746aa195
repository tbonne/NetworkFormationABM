package networkFormation;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import org.apache.commons.collections.IteratorUtils;
import org.apache.commons.math3.distribution.BinomialDistribution;
import org.rosuda.REngine.Rserve.RConnection;
import org.rosuda.REngine.Rserve.RserveException;

import repast.simphony.engine.environment.RunEnvironment;
import repast.simphony.engine.schedule.ScheduledMethod;
import repast.simphony.random.RandomHelper;
import repast.simphony.space.graph.Network;
import repast.simphony.space.graph.RepastEdge;

public class Executor {

	public static int stepCounter;
	public static double cosS,cosSPr,clusteringC,meanBetweennes,modularity,strength;
	public static double startingClusteringC,startingMeanBetweennes,startingModularity,startingStrength;
	public static ArrayList<Double> meanNodeDegreeArray, clusteringCoefArray, cosineArray,cosinePrArray,modularityArray,betweennesArray,strengthArray;
	private static BinomialDistribution bd_Pwr, bd_Pwn;

	public Executor (){
		cosS = 0;
		clusteringC=0;
		modularity=0;
		strength=0;
		meanNodeDegreeArray = new ArrayList<Double>();
		clusteringCoefArray = new ArrayList<Double>();
		cosineArray = new ArrayList<Double>();
		cosinePrArray = new ArrayList<Double>();
		modularityArray = new ArrayList<Double>();
		betweennesArray = new ArrayList<Double>();
		strengthArray = new ArrayList<Double>();
		
		stepCounter=0;
		bd_Pwr = new BinomialDistribution(Parameter_set.maxGroomingEffort, Parameter_set.Pwr);
		bd_Pwn = new BinomialDistribution(Parameter_set.maxGroomingEffort, Parameter_set.Pwn);
	}

	/******************************************************************************************************/
	/************************************ Main model behaivour ********************************************/
	/******************************************************************************************************/

	//The network as a whole goes through this each time step
	public static void step (){

		//modify network
		removeOneIndividual();
		addNewIndividual();

		//process nodes (right now this only measures degree of each node at each time step)
		for(Node node : ModelSetup.getNodes()){
			node.step();
		}

		//step counter 
		stepCounter++;

		if(stepCounter>Parameter_set.endAt){
			endModel();
		}
	}


	/******************************************************************************************************/
	/************************************ Behaviour details ***********************************************/
	/******************************************************************************************************/


	public static void removeOneIndividual(){
		Node dead = ModelSetup.getRandNode();
		dead.setDead(1);
	}


	public static void addNewIndividual(){

		//choose random mother
		Node mother = ModelSetup.getRandNode();

		//create new id
		Node newID = new Node("newID");
		ModelSetup.getContext().add(newID);
		ModelSetup.addNode(newID);

		//create ties
		createTies(newID, mother);

	}

	private static void createTies(Node offspring, Node mother){

		Network net = ModelSetup.getNetwork();

		//get mother links (if any)
		List<Node> motherPartners = mother.getMyNeigh();

		//loop though and create links based on Pn, Pr, Pb, and Pw
		for(Node node:ModelSetup.getNodes()){

			//If the node is not the offspring in question
			if(node.equals(offspring)==false){

				//If this node is the mother
				if(node.equals(mother)){
					//this is Pb
					if(RandomHelper.nextDouble()<Parameter_set.Pb){
						double sample = bd_Pwn.sample();
						net.addEdge(offspring, mother,sample);
					}

					//If this node is not the mother
				} else {

					//this is Pn: mother's partner
					if(motherPartners.contains(node)){
						if(RandomHelper.nextDouble()<Parameter_set.Pn){
							double sample = bd_Pwn.sample();
							net.addEdge(offspring, node,sample);
						}

					//this is Pr: unknown partner
					} else {
						if(RandomHelper.nextDouble()<Parameter_set.Pr){
							double sample = bd_Pwr.sample();
							net.addEdge(offspring, node,sample);
						}
					}
				}
			}
		}

		offspring.myNeigh = IteratorUtils.toList(net.getAdjacent(offspring).iterator());
		recordNetworkStats(offspring, mother);

	}


	private static void recordNetworkStats(Node offspring, Node mother){


		try {
			RConnection c = new RConnection();
			NetStats.calculateCosineSimilarity(c,offspring, mother);
			NetStats.calculateGraphLevelStats(c);
			c.close();
		} catch (RserveException e) {
			//TODO Auto-generated catch block
			e.printStackTrace();
		}



	}


	/******************************************************************************************************/
	/************************************ Simulation tools/methods ****************************************/
	/******************************************************************************************************/

	//This is used to remove nodes from the context and network
	public static void removeNode(){


		ArrayList<Node> toBeRemoved = new ArrayList<Node>();
		Network net = ModelSetup.getNetwork();
		//System.out.println("removing nodes");

		for (Node n:ModelSetup.allNodes){
			if(n.dead==1)toBeRemoved.add(n);
		}

		for(Node n:toBeRemoved){
			try{
				for(RepastEdge e : n.myEdges){
					ModelSetup.getContext().remove(e);
				}
			}catch(NullPointerException ee){
				//no edges to remove
			}

			ModelSetup.allNodes.remove(n);
			ModelSetup.getContext().remove(n);

		}
	}

 	private static void endModel(){
		RunEnvironment.getInstance().endAt(RunEnvironment.getInstance().getCurrentSchedule().getTickCount());
	}

	/******************************************************************************************************/
	/************************************ Output tools/methods ****************************************/
	/******************************************************************************************************/

	
	public static void output(){
		output_eachTimeStep();
		output_finalDistances();
	}

	private static void output_eachTimeStep(){

		//Create the writer and the output file
		BufferedWriter summaryStats_out=null;
		try {
			summaryStats_out = new BufferedWriter(new FileWriter("NetworkFormation_output.csv", false));
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		//Transfer the recorded data to the output file
		try {

			//record parameters
			summaryStats_out.append("Pb = ");
			summaryStats_out.append(((Double)Parameter_set.Pb).toString());
			summaryStats_out.append(", ");
			summaryStats_out.append("Pn = ");
			summaryStats_out.append(((Double)Parameter_set.Pn).toString());
			summaryStats_out.append(", ");
			summaryStats_out.append("Pr = ");
			summaryStats_out.append(((Double)Parameter_set.Pr).toString());
			summaryStats_out.append(", ");
			summaryStats_out.newLine();
			summaryStats_out.newLine();

			//set header
			summaryStats_out.append("MeanDegree,ClusteringCoef,CosineSimilarity,MeanBetweennes,Modularity,TimeStamp");
			summaryStats_out.newLine();

			//record values
			for(int i = 0 ; i<meanNodeDegreeArray.size();i++){

				summaryStats_out.append(((Double)meanNodeDegreeArray.get(i)).toString());
				summaryStats_out.append(",");
				summaryStats_out.append(((Double)clusteringCoefArray.get(i)).toString());
				summaryStats_out.append(",");
				summaryStats_out.append(((Double)cosineArray.get(i)).toString());
				summaryStats_out.append(",");
				summaryStats_out.append(((Double)betweennesArray.get(i)).toString());
				summaryStats_out.append(",");
				summaryStats_out.append(((Double)modularityArray.get(i)).toString());
				summaryStats_out.append(",");
				summaryStats_out.append(((Integer)(i)).toString());
				summaryStats_out.newLine();
			}

			summaryStats_out.flush();
			summaryStats_out.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	private static void output_finalDistances(){

		//Create the writer and the output file
		BufferedWriter summaryStats_out=null;
		try {
			summaryStats_out = new BufferedWriter(new FileWriter("C:/Users/t-work/Documents/GitHub/NetworkFormationABM/NetworkFormation/NetworkFormation_output_distances.csv", true));
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		//calculate mean and sd of cosine estimates
		double mean = 0,meanPr=0;
		for(int i = 0; i < Parameter_set.cosineMeanLength;i++){
			mean = mean + cosineArray.get(cosineArray.size()-1-i);
			meanPr = meanPr + cosinePrArray.get(cosinePrArray.size()-1-i);
		}
		mean = mean / (double)Parameter_set.cosineMeanLength;
		meanPr = meanPr / (double)Parameter_set.cosineMeanLength;
		
		double sd = 0, sdPr= 0;
		for(int i = 0; i < Parameter_set.cosineMeanLength;i++){
			sd = sd + Math.pow(mean - cosineArray.get(cosineArray.size()-1-i),2);
			sdPr = sdPr + Math.pow(meanPr - cosinePrArray.get(cosinePrArray.size()-1-i),2);
		}
		sd = Math.pow(sd/(Parameter_set.cosineMeanLength-1),0.5);
		sdPr = Math.pow(sdPr/(Parameter_set.cosineMeanLength-1),0.5);
		
		//print sum of squares output for r to use
		double ss_strength = Math.pow(strengthArray.get(strengthArray.size()-1)-startingStrength, 2);
		double ss_betweenness = Math.pow(betweennesArray.get(betweennesArray.size()-1)-startingMeanBetweennes, 2);
		double ss_clustering = Math.pow(clusteringCoefArray.get(clusteringCoefArray.size()-1)-startingClusteringC, 2);
		System.out.println(ss_strength); 	//degree
		System.out.println(ss_betweenness); //transitivity
		System.out.println(ss_clustering); 	//betweenness

		//Transfer the recorded data to the output file
		try {

			//record values
			summaryStats_out.append(((Double)strengthArray.get(0)).toString());
			summaryStats_out.append(",");
			summaryStats_out.append(((Double)clusteringCoefArray.get(0)).toString());
			summaryStats_out.append(",");
			summaryStats_out.append(((Double)cosineArray.get(0)).toString());
			summaryStats_out.append(",");
			summaryStats_out.append(((Double)betweennesArray.get(0)).toString());
			summaryStats_out.append(",");
			summaryStats_out.append(((Double)modularityArray.get(0)).toString());
			summaryStats_out.append(",");
			summaryStats_out.append(((Double)strengthArray.get(strengthArray.size()-1)).toString());
			summaryStats_out.append(",");
			summaryStats_out.append(((Double)clusteringCoefArray.get(clusteringCoefArray.size()-1)).toString());
			summaryStats_out.append(",");
			//summaryStats_out.append(((Double)cosineArray.get(cosineArray.size()-1)).toString());
			summaryStats_out.append(((Double)mean).toString());
			summaryStats_out.append(",");
			summaryStats_out.append(((Double)sd).toString());
			summaryStats_out.append(",");
			summaryStats_out.append(((Double)meanPr).toString());
			summaryStats_out.append(",");
			summaryStats_out.append(((Double)sdPr).toString());
			summaryStats_out.append(",");
			summaryStats_out.append(((Double)betweennesArray.get(betweennesArray.size()-1)).toString());
			summaryStats_out.append(",");
			summaryStats_out.append(((Double)modularityArray.get(modularityArray.size()-1)).toString());
			summaryStats_out.append(",");
			summaryStats_out.append(((Integer)(Parameter_set.endAt)).toString());
			summaryStats_out.append(", ");
			summaryStats_out.append(((Double)Parameter_set.Pb).toString());
			summaryStats_out.append(", ");
			summaryStats_out.append(((Double)Parameter_set.Pn).toString());
			summaryStats_out.append(", ");
			summaryStats_out.append(((Double)Parameter_set.Pr).toString());
			summaryStats_out.append(", ");
			summaryStats_out.append(((Double)Parameter_set.Pwr).toString());
			summaryStats_out.append(", ");
			summaryStats_out.append(((Double)Parameter_set.Pwn).toString());
			summaryStats_out.newLine();

			summaryStats_out.flush();
			summaryStats_out.close();
		} catch (IOException e) {
			e.printStackTrace();
		}

	}


	/******************************************************************************************************/
	/************************************ Get/Set tools/methods ****************************************/
	/******************************************************************************************************/


	public static double getCosineSimilarity(){
		return cosS;
	}
	public static void setCosineSimilarity(double s){
		cosS = s;
	}
	public static double getClusteringCoef(){
		return clusteringC;
	}
	public static void setClusteringCoef(double s){
		clusteringC = s;
	}
	public static void addToMeanDegreeArray(double d){
		meanNodeDegreeArray.add(d);
	}
	public static void addToClusteringCoefArray(double d){
		clusteringCoefArray.add(d);
	}
	public static void addToCosineArray(double d){
		cosineArray.add(d);
	}
	public static void addToCosinePrArray(double d){
		cosinePrArray.add(d);
	}
	public static void setBetweennessCoef(double d){
		meanBetweennes = d;
	}
	public static double getBetweennessCoef(){
		return meanBetweennes;
	}
	public static void addToBetweennessCoefArray(double d){
		betweennesArray.add(d);
	}
	public static void addToModularityArray(double d){
		modularityArray.add(d);
	}
	public static void addToStrengthArray(double d){
		strengthArray.add(d);
	}
	public static void setModularity(double d){
		modularity = d;
	}
	public static double getModularity(){
		return modularity;
	}
	public static void setStrength(double d){
		strength = d;
	}
	public static double getStrength(){
		return strength;
	}
	public static void setCosineSimilarityPr(double cosPr) {
		cosSPr = cosPr;
	}

	public static void setStartingClusteringCoef(double cluster) {
		startingClusteringC = cluster;
	}

	public static void setStartingBetweennessCoef(double bet) {
		startingMeanBetweennes = bet;
	}

	public static void setStartingModularity(double modularity2) {
		startingModularity = modularity2;
	}

	public static void setStartingStrength(double stre) {
		startingStrength = stre;
	}

}
